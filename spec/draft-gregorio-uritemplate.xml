<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
 <!ENTITY rfc2119 SYSTEM 'bibxml/reference.RFC.2119.xml'>
 <!ENTITY rfc3986 SYSTEM 'bibxml/reference.RFC.3986.xml'>
 <!ENTITY rfc3987 SYSTEM 'bibxml/reference.RFC.3987.xml'>
 <!ENTITY rfc5234 SYSTEM 'bibxml/reference.RFC.5234.xml'>
 <!ENTITY rfc2978 SYSTEM 'bibxml/reference.RFC.2978.xml'>
 <!ENTITY rfc3629 SYSTEM 'bibxml/reference.RFC.3629.xml'>
 <!ENTITY ASCII   SYSTEM 'bibxml/_reference.ANSI.X3-4.1986.xml'>
 <!ENTITY UNIV4   SYSTEM 'bibxml/univ4.xml'>
 <!ENTITY UTR15   SYSTEM 'bibxml/utr15.xml'>
 ]>

<!--<?xml-stylesheet type='text/xsl' href='rfc2629.xslt'/ ?>-->

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="yes" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes" ?>
<?rfc linkmailto="no" ?>
<?rfc tocdepth="3" ?>
<!--
 1. Update the docName
 2. Update the date
 3. Update the Revision History.
-->

<rfc category="std" ipr="pre5378Trust200902" docName="draft-gregorio-uritemplate-04">
 <front>
  <title>URI Template</title>

  <author initials='J.C.' surname="Gregorio" fullname='Joe Gregorio' role="editor">
   <organization>Google</organization>
   <address>
    <email>joe@bitworking.org</email>
    <uri>http://bitworking.org/</uri>
   </address>
  </author>

  <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
   <organization abbrev="Day Software">Day Software</organization>
   <address>
    <email>fielding@day.com</email>
    <uri>http://www.day.com/</uri>
   </address>
  </author>

  <author initials='M.H.' surname="Hadley" fullname='Marc Hadley' role="editor">
   <organization>Oracle</organization>
   <address>
    <email>Marc.Hadley@oracle.com</email>
    <uri>http://oracle.com/</uri>
   </address>
  </author>

  <author initials='M.N.' surname="Nottingham" fullname='Mark Nottingham' role="editor">
   <organization></organization>
   <address>
    <email>mnot@pobox.com</email>
    <uri>http://mnot.net/</uri>
   </address>
  </author>

  <author initials='D.O.' surname="Orchard" fullname='David Orchard'>
   <organization></organization>
   <address>
    <uri>http://www.pacificspirit.com/</uri>
   </address>
  </author>

  <date day="08" month="Jul" year="2009"/>
  <abstract>
   <t>
    A URI Template is a compact sequence of characters
    for describing a range of Uniform Resource Identifiers
    through variable expansion.
    This specification defines the URI Template
    syntax and the process for expanding a URI Template into a
    URI, along with guidelines for the
    use of URI Templates on the Internet.
   </t>
  </abstract>

  <note title="Editorial Note (to be removed by RFC Editor)">
   <t>
    To provide feedback on this Internet-Draft, join the
    <eref target="http://lists.w3.org/Archives/Public/uri/">W3C URI
    mailing list (http://lists.w3.org/Archives/Public/uri/)</eref>.
   </t>
  </note>
 </front>

 <middle>
  <section title="Introduction" anchor="intro">
   <section title="Overview" anchor="overview">
    <t>
     A Uniform Resource Identifier (URI) <xref target="RFC3986"/>
     is often used to identify a specific resource within a common
     space of similar resources. For example, personal web spaces
     are often delegated using a common pattern, such as
    </t>
    <figure><artwork>
  http://example.com/~fred/
  http://example.com/~mark/
    </artwork></figure>
    <t>
     or a set of dictionary entries might be grouped in a hierarchy
     by the first letter of the term, as in
    </t>
    <figure><artwork>
  http://example.com/dictionary/c/cat
  http://example.com/dictionary/d/dog
    </artwork></figure>
    <t>
     or a service interface might be invoked with various user input
     in a common pattern, as in
    </t>
    <figure><artwork>
  http://example.com/search?q=cat&amp;lang=en
  http://example.com/search?q=dog&amp;lang=fr
    </artwork></figure>
    <t>
     URI Templates provide a mechanism for abstracting a space of
     resource identifiers such that the variable parts can be easily
     identified and described.  URI templates can have many uses,
     including discovery of available services, configuring resource
     mappings, defining computed links, specifying interfaces, and
     other forms of programmatic interaction with resources.
     For example, the above resources could be described by the
     following URI templates:
    </t>
    <figure><artwork>
  http://example.com/~{username}/
  http://example.com/dictionary/{term:1}/{term}
  http://example.com/search{?q,lang}
    </artwork></figure>
    <t>
     We define the following terms:
     <list style="symbols">
      <t>expression -
         The text between '{' and '}', including the enclosing braces,
         as defined in <xref target="syntax"/>.</t>
      <t>expansion -
         The string result obtained from a template expression after
         processing it according to its expression type, list of variable
         names, and value modifiers, as defined in <xref target="expansion"/>.</t>
      <t>template processor -
         A program or library that, given a URI Template and a set of
         variables with values, transforms the template string into a
         URI-reference by parsing the template for expressions and
         substituting each one with its corresponding expansion.</t>
      </list>
     </t>
    <t>
     A URI Template provides both a structural description of a URI
     space and, when variable values are provided, a simple instruction
     on how to construct a URI corresponding to those values.
     A URI Template is transformed into a URI-reference by replacing each
     delimited expression with its value as defined by the
     expression type and the values of variables named within the
     expression.  The expression types range from simple value
     expansion to multiple key=value lists.  The expansions
     are based on the URI generic syntax, allowing an implementation
     to process any URI Template without knowing the scheme-specific
     requirements of every possible resulting URI.
    </t>
    <t>
     A URI Template may be provided in absolute form, as in the examples
     above, or in relative form if a suitable base URI is defined.
    </t>
    <t>
     Although the URI syntax is used for the result, the template
     string is allowed to contain the broader set of characters
     that can be found in IRI references <xref target="RFC3987"/>.
     A URI Template is therefore also an IRI template, and the result
     of template processing can be rendered as an IRI by transforming
     the pct-encoded sequences to their corresponding Unicode
     character if the character is not in the reserved set.
    </t>
   </section>

   <section title="Expression Types" anchor="types">
    <t>
     URI Templates are similar to a macro language with a fixed set of
     macro definitions: the expression type determines the expansion
     process.  For example, the following URI Template includes a
     form-style parameter expression, as indicated by the "?" operator
     appearing before the variable names.
    </t>
    <figure><artwork>
  http://www.example.com/foo{?query,number}
    </artwork></figure>
    <t>
     Each template expression describes in a machine-readable manner
     how a URI is to be constructed.  In this example,
     the expansion process for templates beginning with the
     question-mark ("?") operator follows the same pattern
     as form-style interfaces on the World Wide Web.
    </t>
    <figure><artwork>
  http://www.example.com/foo{?query,number}
                            \_____________/
                               |
                               |
          For each defined variable in [ 'query', 'number' ],
          substitute "?" if it is the first substitution or "&amp;"
          thereafter, followed by the variable name, '=', and the
          variable's value.
    </artwork></figure>
    <t>
     If the variables have the values
    </t>
    <figure><artwork>
  query  := "mycelium"
  number := 100
    </artwork></figure>
    <t>
     then the expansion of the above URI Template is
    </t>
    <figure><artwork>
  http://www.example.com/foo?query=mycelium&amp;number=100
    </artwork></figure>
    <t>
     Alternatively, if 'query' is undefined, then the expansion
     would be
    </t>
    <figure><artwork>
  http://www.example.com/foo?number=100
    </artwork></figure>
    <t>
     or if both variables are undefined, then it would be
    </t>
    <figure><artwork>
  http://www.example.com/foo
    </artwork></figure>
    <t>
     The following table summarizes each type of template
     expression by its associated operator and cross-references
     the section of this document that defines the operator and
     its specific expansion process.  The example expansions are
     based on the following variables and values:
    </t>
    <figure><artwork>
   var   := "value";
   hello := "Hello World!";
   undef := null;
   empty := "";
   list  := [ "val1", "val2", "val3" ];
   keys  := [("key1", "val1"), ("key2", "val2")];
   path  := "/foo/bar"
   x     := "1024";
   y     := "768";

.-----------------------------------------------------------------.
| Sec | Op  | Description                                         |
|     |     |    Expression      | Expansion                      |
|-----+-----+-----------------------------------------------------|
| 3.3 |     | Simple expansion with comma-separated values        |
|     |     |                                                     |
|     |     |    {var}             value                          |
|     |     |    {hello}           Hello%20World%21               |
|     |     |    {path}/here       %2Ffoo%2Fbar/here              |
|     |     |    {x,y}             1024,768                       |
|     |     |    {var=default}     value                          |
|     |     |    {undef=default}   default                        |
|     |     |    {list}            val1,val2,val3                 |
|     |     |    {list*}           val1,val2,val3                 |
|     |     |    {list+}           list.val1,list.val2,list.val3  |
|     |     |    {keys}            key1,val1,key2,val2            |
|     |     |    {keys*}           key1,val1,key2,val2            |
|     |     |    {keys+}           keys.key1,val1,keys.key2,val2  |
|     |     |                                                     |
|-----+-----+-----------------------------------------------------|
| 3.4 |  +  | Reserved expansion with comma-separated values      |
|     |     |                                                     |
|     |     |    {+var}            value                          |
|     |     |    {+hello}          Hello%20World!                 |
|     |     |    {+path}/here      /foo/bar/here                  |
|     |     |    {+path,x}/here    /foo/bar,1024/here             |
|     |     |    {+path}{x}/here   /foo/bar1024/here              |
|     |     |    {+empty}/here     /here                          |
|     |     |    {+undef}/here     /here                          |
|     |     |    {+list}           val1,val2,val3                 |
|     |     |    {+list*}          val1,val2,val3                 |
|     |     |    {+list+}          list.val1,list.val2,list.val3  |
|     |     |    {+keys}           key1,val1,key2,val2            |
|     |     |    {+keys*}          key1,val1,key2,val2            |
|     |     |    {+keys+}          keys.key1,val1,keys.key2,val2  |
|     |     |                                                     |
|-----+-----+-----------------------------------------------------|
| 3.5 |  ;  | Path-style parameters, semicolon-prefixed           |
|     |     |                                                     |
|     |     |    {;x,y}            ;x=1024;y=768                  |
|     |     |    {;x,y,empty}      ;x=1024;y=768;empty            |
|     |     |    {;x,y,undef}      ;x=1024;y=768                  |
|     |     |    {;list}           ;val1,val2,val3                |
|     |     |    {;list*}          ;val1;val2;val3                |
|     |     |    {;list+}          ;list=val1;list=val2;list=val3 |
|     |     |    {;keys}           ;key1,val1,key2,val2           |
|     |     |    {;keys*}          ;key1=val1;key2=val2           |
|     |     |    {;keys+}          ;keys.key1=val1;keys.key2=val2 |
|     |     |                                                     |
|-----+-----+-----------------------------------------------------|
| 3.6 |  ?  | Form-style parameters, ampersand-separated          |
|     |     |                                                     |
|     |     |    {?x,y}            ?x=1024&amp;y=768                  |
|     |     |    {?x,y,empty}      ?x=1024&amp;y=768&amp;empty=           |
|     |     |    {?x,y,undef}      ?x=1024&amp;y=768                  |
|     |     |    {?list}           ?list=val1,val2,val3           |
|     |     |    {?list*}          ?val1&amp;val2&amp;val3                |
|     |     |    {?list+}          ?list=val1&amp;list=val2&amp;list=val3 |
|     |     |    {?keys}           ?keys=key1,val1,key2,val2      |
|     |     |    {?keys*}          ?key1=val1&amp;key2=val2           |
|     |     |    {?keys+}          ?keys.key1=val1&amp;keys.key2=val2 |
|     |     |                                                     |
|-----+-----+-----------------------------------------------------|
| 3.7 |  /  | Hierarchical path segments, slash-separated         |
|     |     |                                                     |
|     |     |    {/var}            /value                         |
|     |     |    {/var,empty}      /value/                        |
|     |     |    {/var,undef}      /value                         |
|     |     |    {/list}           /val1,val2,val3                |
|     |     |    {/list*}          /val1/val2/val3                |
|     |     |    {/list*,x}        /val1/val2/val3/1024           |
|     |     |    {/list+}          /list.val1/list.val2/list.val3 |
|     |     |    {/keys}           /key1,val1,key2,val2           |
|     |     |    {/keys*}          /key1/val1/key2/val2           |
|     |     |    {/keys+}          /keys.key1/val1/keys.key2/val2 |
|     |     |                                                     |
|-----+-----+-----------------------------------------------------|
| 3.8 |  .  | Label expansion, dot-prefixed                       |
|     |     |                                                     |
|     |     |    X{.var}          X.value                         |
|     |     |    X{.empty}        X.                              |
|     |     |    X{.undef}        X                               |
|     |     |    X{.list}         X.val1,val2,val3                |
|     |     |    X{.list*}        X.val1.val2.val3                |
|     |     |    X{.list*,x}      X.val1.val2.val3.1024           |
|     |     |    X{.list+}        X.list.val1.list.val2.list.val3 |
|     |     |    X{.keys}         X.key1,val1,key2,val2           |
|     |     |    X{.keys*}        X.key1.val1.key2.val2           |
|     |     |    X{.keys+}        X.keys.key1.val1.keys.key2.val2 |
|     |     |                                                     |
`-----+-----+-----------------------------------------------------'
    </artwork></figure>
   </section>

   <section title="Design Considerations" anchor="design">
    <t>
     The URI Template syntax has been designed to carefully balance
     the need for a powerful expansion mechanism with ease of
     implementation and security. The syntax is designed to be easy
     to parse while at the same time providing enough flexibility to
     express many common template scenarios.  Implementations are able
     to parse the template and perform the expansions in a single pass.
    </t>
    <t>
     Templates are simple and readable when used with common
     examples because the single-character operators match the URI
     generic syntax delimiters.  The operator's associated delimiter
     (";", "?", "/", and ".") is omitted when none of the listed variables
     are defined.  Likewise, the expansion process for ";"
     (path-style parameters) will omit the "=" when the variable value
     is empty, whereas the process for "?" (form-style parameters)
     will not omit the "=" when the value is empty.  Multiple variables
     and list values have their values joined with "," if there is no
     predefined joining mechanism for the operator.  Only one operator,
     plus ("+"), will substitute unencoded reserved characters found
     inside the variable values; the other operators will pct-encode
     reserved characters found in the variable values prior to expansion.
    </t>
    <t>
     The most common cases for URI spaces can be described with
     simple URI Template expressions.  If we were only concerned with
     URI generation, then the template syntax could be limited to
     just simple variable expansion, since more complex forms could
     be generated by changing the variable definitions.  However, URI
     Templates have the additional goal of describing the layout of
     identifiers in terms of preexisting data values.  The template
     syntax must therefore include operators that can reflect how
     resource identifiers are commonly allocated.  Likewise, since
     prefix and suffix substrings are often used to partition large
     spaces of resources, modifiers on variable values provide a way
     to specify those substrings.
    </t>
    <t>
     Mechanisms similar to URI Templates have been defined within
     several specifications, including WSDL, WADL and OpenSearch.
     This specification extends and formally defines the syntax so
     that URI Templates can be used consistently across multiple
     Internet applications and within Internet message fields.
    </t>
   </section>

   <section title="Limitations" anchor="limitations">
    <t>
     Since a URI Template describes a superset of the identifiers,
     there is no implication that every possible expansion for
     each delimited variable expression corresponds to a URI of an
     existing resource.  Our expectation is that an application
     constructing URIs according to the template will be provided
     with an appropriate set of values for the variables being
     substituted and will be able to cope with any errors that might
     occur when the resulting URI is used for name resolution or access.
    </t>
    <t>
     URI Template expressions are not URIs: they do not identify
     an abstract or physical resource, they are not parsed as URIs,
     and should not be used in places where a URI would be expected
     unless the template expressions will be expanded by a template
     processor prior to use.  Distinct field, element, or attribute
     names should be used to differentiate protocol elements that
     carry a URI Template from those that expect a URI-reference.
    </t>
   </section>

   <section title="Notational Conventions" anchor="notation">
    <t>
     The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
     "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",
     "MAY", and "OPTIONAL" in this document are to be
     interpreted as described in <xref target="RFC2119"/>.
    </t>
    <t>
     This specification uses the terms "character" and "coded
     character set" in accordance with the definitions provided
     in <xref target="RFC2978"/>, and "character encoding" in
     place of what <xref target="RFC2978"/> refers to as a "charset".
    </t>
   </section>

   <section title="ABNF and Character Encoding" anchor="abnf-encoding">
    <t>
     This specification uses the Augmented Backus-Naur Form (ABNF)
     notation of <xref target="RFC5234"/>.  The following ABNF rules
     are imported from the normative references <xref target="RFC5234"/>,
     <xref target="RFC3986"/>, and <xref target="RFC3987"/>.
    </t>
    <figure><artwork type="abnf">
  ALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z
  DIGIT          =  %x30-39             ; 0-9
  HEXDIG         =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
  
  pct-encoded    =  "%" HEXDIG HEXDIG
  unreserved     =  ALPHA / DIGIT / "-" / "." / "_" / "~"
  reserved       =  gen-delims / sub-delims
  gen-delims     =  ":" / "/" / "?" / "#" / "[" / "]" / "@"
  sub-delims     =  "!" / "$" / "&amp;" / "'" / "(" / ")"
                 /  "*" / "+" / "," / ";" / "="
      
  ucschar        =  %xA0-D7FF / %xF900-FDCF / %xFDF0-FFEF
                 /  %x10000-1FFFD / %x20000-2FFFD / %x30000-3FFFD
                 /  %x40000-4FFFD / %x50000-5FFFD / %x60000-6FFFD
                 /  %x70000-7FFFD / %x80000-8FFFD / %x90000-9FFFD
                 /  %xA0000-AFFFD / %xB0000-BFFFD / %xC0000-CFFFD
                 /  %xD0000-DFFFD / %xE1000-EFFFD

  iprivate       =  %xE000-F8FF / %xF0000-FFFFD / %x100000-10FFFD
    </artwork></figure>
    <t>
     A URI Template is defined as a sequence of characters and therefore
     has the same issues as URIs with regard to codepoints and character sets.
     That is, URI Template characters are frequently encoded as octets
     for transport or presentation.  This specification does not mandate
     any particular character encoding for mapping between URI Template
     characters and the octets used to store or transmit those characters.
     When a URI Template appears in a protocol element, the character
     encoding is defined by that protocol; without such a definition,
     a URI Template is assumed to be in the same character encoding as
     the surrounding text.
    </t>
    <t>
     A URI Template and its associated variable values are converted
     to a normal form of UTF-8 <xref target="RFC3629"/> prior to
     template processing, as defined in <xref target="unicode-normal"/>.
    </t>
    <t>
     The ABNF notation defines its terminal values to be
     non-negative integers (codepoints) that are a superset of the
     US-ASCII coded character set <xref target="ASCII"/>.  This
     specification defines terminal values as codepoints within the
     Unicode coded character set <xref target="UNIV4"/>.  Thus, a string
     of characters in a URI Template is assumed to be transformed into
     its corresponding sequence of Unicode codepoints prior to testing
     for a match with the URI Template grammar.
    </t>
   </section>
  </section>

  <section title="URI Template Syntax" anchor="syntax">
   <t>
    A URI Template is a string of printable Unicode characters
    that contains zero or more embedded variable expressions, each
    expression being delimited by a matching pair of braces ('{', '}').
   </t>
   <figure><artwork type="abnf">
  URI-Template  = *( literals / expression )
   </artwork></figure>

   <section title="Literals" anchor="literals">
    <t>
      The characters outside of expressions in a URI Template string
      are intended to be translated literally to the URI-reference.
      Characters allowed in the URI-reference grammar are copied to
      the result string. Characters not allowed in the URI-reference
      grammar MUST first be encoded using the UTF-8 character encoding,
      each octet of that encoding MUST then be pct-encoded, and the
      resulting sequence of pct-encoded octets is copied to the
      result string.
    </t>
    <figure><artwork type="abnf">
  literals      =  %x21 / %x23-24 / %x26 / %x28-3B / %x3D / %x3F-5B
                /  %x5D-5F / %x61-7A / %x7E / ucschar / iprivate
                /  pct-encoded
                     ; any Unicode character except:
                     ;  CTL, SP, DQUOTE, "'", "%" (aside from pct-encoded),
                     ;  "&lt;", "&gt;", "\", "^", "`", "{", "|", "}"
    </artwork></figure>
   </section>

   <section title="Expressions" anchor="expressions">
    <t>
     Template expressions are the parameterized parts of a URI Template.
     Each expression contains an optional operator, which defines the
     expression type and its corresponding expansion process, followed by a
     comma-separated list of variable specifiers (variable names and
     optional value modifiers).  If no operator is provided, the expression
     defaults to simple variable expansion of unreserved values.
    </t>
    <figure><artwork type="abnf">
  expression    =  "{" [ operator ] variable-list "}"
  operator      =  "+" / "." / "/" / ";" / "?" / op-reserve
  op-reserve    =  "|" / "!" / "@"
                       ; reserved for local use: "$" / "(" / ")"
    </artwork></figure>
   <t>
   </t>
    <t> 
     The operator characters have been chosen to reflect each of their roles
     as reserved characters in the URI generic syntax.  The operators defined
     by this specification include:
     plus ("+") for substituting values that may contain reserved characters;
     dot (".") for substituting values as a sequence of name labels prefixed
     by ".";
     slash ("/") for substituting values as a sequence of path segments
     separated by "/";
     semicolon (";") for substituting key=value pairs as path parameters
     prefixed by ";"; and,
     question-mark ("?") for substituting a query component beginning
     with "?" and consisting of key=value pairs separated by "&amp;".
     These operators will be described in detail in <xref target="expansion"/>.
    </t>
    <t>
     The operator characters pipe ("|"), exclamation ("!"), and at-sign ("@")
     are reserved for future extensions.  A processor that unexpectedly
     encounters such an extension operator SHOULD pass the expression
     through unexpanded and MAY also indicate a warning to the invoking
     application.
    </t>
    <t>
     The expression syntax specifically excludes use of the dollar ("$")
     and parentheses ["(" and ")"] characters so that they remain
     available for local language extensions outside the scope of this
     specification.
    </t>
   </section>

   <section title="Variables" anchor="variables">
    <t>
     After the operator (if any), each expression contains a list of
     one or more comma-separated variable specifiers (varspec).
     The variable names serve multiple purposes: documentation for
     what kinds of values are expected, identifiers for associating
     values within a URI Template processor, and the string to use
     for each key on key=value expansions.
    </t>
    <figure><artwork type="abnf">
  variable-list =  varspec *( "," varspec )
  varspec       =  varname [ modifier ] [ "=" default ]
  varname       =  varchar *( varchar / "." )
  varchar       =  ALPHA / DIGIT / "_" / ucschar / iprivate
                /  pct-encoded
    </artwork></figure>
    <t>
     An expression MAY reference variables that are unknown
     to the template processor or whose value is set to a special
     "undefined" value, such as undef or null.  Such undefined
     variables are given special treatment by the expansion process.
    </t>
    <t>
     A variable value that is a string of length zero is not considered
     undefined; it has the defined value of an empty string.
    </t>
    <t>
     A variable may have a composite or structured value, such as a
     list of values, an associative array of (key, value) pairs, or
     a structure of components defined by some separate schema.
     Such value types are not directly indicated by the template
     syntax, but do have an impact on the expansion process.  A
     composite or structured value with zero member values is
     considered undefined.
    </t>
    <t>
     If a variable appears more than once in an expression or
     within multiple expressions of a URI Template, the value of
     that variable MUST remain static throughout the expansion
     process (i.e., the variable must have the same value for the
     purpose of calculating each expansion).
    </t>
   </section>

   <section title="Value Modifiers" anchor="modifiers">
    <t>
     Any of the variables can have a modifier indicating that its
     value is exploded into components or is limited to a prefix,
     suffix, or the remainder of a prefix or suffix of the variable value.
    </t>
    <figure><artwork type="abnf">
  modifier      =  explode / partial
    </artwork></figure>

    <section title="Component Values" anchor="component-values">
     <t>
      The explode modifiers ("*" and "+") indicate that the
      variable represents a composite value that may be substituted
      in full or partial forms, depending on the variable's type or
      schema.  Since URI Templates do not contain an indication of
      type or schema, this is assumed to be determined by context.
      An example context is a mark-up element or header field that
      contains one attribute that is a template and one or more other
      attributes that define the schema applicable to variables found
      in the template.  Likewise, a typed programming language might
      differentiate variables as strings, lists, associative arrays,
      or structures.
     </t>
    <figure><artwork type="abnf">
  explode       =  ( "*" / "+" )
    </artwork></figure>
     <t>
      The primary difference between the two explode modifiers is
      that an asterisk ("*") indicates that just the component names
      and values are included in the expansion, whereas the plus
      ("+") indicates that each component name is prefixed with the
      given variable name and a period ("."), thereby enabling multiple
      variables with the same component names to be disambiguated.
     </t>
     <t>
      Component modifiers improve brevity in the URI Template syntax.
      For example, a resource that provides a geographic map for a
      given street address might accept a hundred permutations on
      fields for address input, including partial addresses (e.g.,
      just the city or postal code).  Such a resource could be
      described as a template with each and every address component
      listed in order, or with a far more simple template that makes
      use of an explode modifier, as in
     </t>
     <figure><artwork>
   /mapper{?address*}
     </artwork></figure>
     <t>
      or
     </t>
     <figure><artwork>
   /directions{?from+,to+} 
     </artwork></figure>
     <t>
      along with some context that defines each variable (address, from,
      and to) as adhering to a given addressing standard (e.g., UPU S42
      or AS/NZS 4819:2003).  A recipient aware of the schema can then
      provide appropriate expansions, such as:
     </t>
     <figure><artwork>
   /mapper?city=Newport%20Beach&amp;state=CA
   /directions?from.zipcode=92660&amp;to.zipcode=90210
     </artwork></figure>
     <t>
      The expansion process for variables, as defined in
      <xref target="expansion"/>, is dependent on both the
      operator being used and, if one of the explode modifiers is
      used, the type and schema of the variable being substituted.
     </t>
    </section>
    
    <section title="Prefix and Suffix Values" anchor="partial-values">
     <t>
      Prefix and suffix modifiers are often used to partition an identifier
      space hierarchically, as is common in reference indices and hash-based
      storage, or to limit the substituted value to a maximum number of
      characters.
     </t>
    <figure><artwork type="abnf">
  partial       =  ( substring / remainder ) offset
  substring     =  ":"
  remainder     =  "^"
  offset        =  [ from-end ] 1*DIGIT
  from-end      =  "-"
    </artwork></figure>
     <t>
      The offset refers to a maximum number of characters from either
      the beginning (prefix) or end (suffix) of the variable's value as
      a Unicode string.  Note that this numbering is in characters, not
      octets, in order to avoid substituting improperly encoded values
      due to splitting a multi-octet UTF-8 encoded character or a
      pct-encoded triplet.
     </t>
     <t>
      A substring modifier requires that only the indicated prefix or
      suffix be used in the expansion.  A remainder modifier requires
      that only the remainder of the value, excluding the indicated prefix
      or suffix, be used in the expansion.  If the offset is greater than
      the length of the variable's value, then the entire string is used
      for a substring and the empty string is used for a remainder.
     </t>
    <t>
     The following examples illustrate how modifiers work with the
     different variable types.  More complex examples are provided
     in <xref target="examples"/>.
    </t>
    <figure><artwork>
  Given the variable assignments:
    var   := "value";
    name  := [ "Fred", "Wilma", "Pebbles" ];

  Example Template     Expansion

    {var}              value
    {var:20}           value
    {var:3}            val
    {var^3}            ue
    {var:-3}           lue
    {var^-3}           va

    {?name}            ?name=Fred,Wilma,Pebbles
    {?name:1}          ?name=F
    </artwork></figure>
    </section>
   </section>

   <section title="Value Defaults" anchor="defaults">
    <t>
     Any of the variables may also be supplied with a default value
     to be used when a template processor determines the variable to be
     undefined. The default value is limited to the unreserved and
     pct-encoded characters of a URI-reference, since our intention
     is for the default to be presented in the exact form that it would
     appear in the resulting URI.  The default is not affected by the
     variable modifiers; it is assumed that the default string
     provided in the expression already reflects any necessary
     substring or remainder processing.
    </t>
    <figure><artwork type="abnf">
  default       =  *( unreserved / pct-encoded )
    </artwork></figure>
    <t>
     The following examples illustrate how default values work with
     different variable types.  More complex examples are provided
     in <xref target="examples"/>.
    </t>
    <figure><artwork>
  Given the variable assignments:
    var   := "value";
    empty := "";
    undef := null;
    name  := [ "Fred", "Wilma", "Pebbles" ];
    favs  := [("color","red"), ("volume","high")];
    empty_list := [];
    empty_keys := [];

  Example Template        Expansion

    {var=default}         value
    {undef=default}       default

    x{empty}y             xy
    x{empty=_}y           xy
    x{undef}y             xy
    x{undef=_}y           x_y

    x{empty_list}y        xy
    x{empty_list=_}y      xy
    x{empty_list*}y       xy
    x{empty_list*=_}y     x_y
    x{empty_list+}y       xy
    x{empty_list+=_}y     xempty_list._y

    x{empty_keys}y        xy
    x{empty_keys=_}y      xy
    x{empty_keys*}y       xy
    x{empty_keys*=_}y     x_y
    x{empty_keys+}y       xy
    x{empty_keys+=_}y     xempty_keys._y
    
    x{?name=none}         x?name=Fred,Wilma,Pebbles
    x{?favs=none}         x?favs=color,red,volume,high
    x{?favs*=none}        x?color=red&amp;volume=high
    x{?favs+=none}        x?favs.color=red&amp;favs.volume=high
    
    x{?undef}             x
    x{?undef=none}        x?undef=none
    x{?empty}             x?empty=
    x{?empty=none}        x?empty=

    x{?empty_list}        x
    x{?empty_list=none}   x?empty_list=none
    x{?empty_list*}       x
    x{?empty_list*=none}  x?none
    x{?empty_list+}       x
    x{?empty_list+=none}  x?empty_list.none

    x{?empty_keys}        x
    x{?empty_keys=none}   x?empty_keys=none
    x{?empty_keys*}       x
    x{?empty_keys*=none}  x?none
    x{?empty_keys+}       x
    x{?empty_keys+=none}  x?empty_keys.none
    
    x{;name=none}         x;name=Fred,Wilma,Pebbles
    x{;favs=none}         x;favs=color,red,volume,high
    x{;favs*=none}        x;color=red;volume=high
    x{;favs+=none}        x;favs.color=red;favs.volume=high
    
    x{;undef}             x
    x{;undef=none}        x;undef=none
    x{;empty}             x;empty
    x{;empty=none}        x;empty

    x{;empty_list}        x
    x{;empty_list=none}   x;empty_list=none
    x{;empty_list*}       x
    x{;empty_list*=none}  x;none
    x{;empty_list+}       x
    x{;empty_list+=none}  x;empty_list.none
    
    x{;empty_keys}        x
    x{;empty_keys=none}   x;empty_keys=none
    x{;empty_keys*}       x
    x{;empty_keys*=none}  x;none
    x{;empty_keys+}       x
    x{;empty_keys+=none}  x;empty_keys.none
    
    x{/name=none}         x/Fred,Wilma,Pebbles
    x{/name*=none}        x/Fred/Wilma/Pebbles
    x{/name+=none}        x/name.Fred/name.Wilma/name.Pebbles
    x{/favs=none}         x/color,red,volume,high
    x{/favs*=none}        x/color/red/volume/high
    x{/favs+=none}        x/favs.color/red/favs.volume/high
    
    x{/undef}             x
    x{/undef=none}        x/none
    x{/empty}             x/
    x{/empty=none}        x/
    
    x{/empty_list}        x
    x{/empty_list=none}   x/none
    x{/empty_list*}       x
    x{/empty_list*=none}  x/none
    x{/empty_list+}       x
    x{/empty_list+=none}  x/empty_list.none
    
    x{/empty_keys}        x
    x{/empty_keys=none}   x/none
    x{/empty_keys*}       x
    x{/empty_keys*=none}  x/none
    x{/empty_keys+}       x
    x{/empty_keys+=none}  x/empty_keys.none
    </artwork></figure>
   </section>
  </section>

  <section title="URI Template Expansion" anchor="expansion">
   <t>
    The process of URI Template expansion is to scan the template
    string from beginning to end, copying literal characters as-is
    and replacing each expression with the result of applying the
    expression's operator to the value of each variable named in
    the expression.
   </t>
   <t>
    If a template processor encounters an error, such as an operator
    that it does not understand or a character sequence that does not
    match the &lt;URI-Template&gt; grammar, then processing of the
    template SHOULD cease, the URI-reference result SHOULD be undefined,
    and the location and type of error SHOULD be indicated to the
    invoking application.
   </t>
   <t>
    If a template processor encounters a warning, such as the use of
    an operator character reserved for future extension, then the
    processing of the template SHOULD NOT cease, and the location
    and type of warning SHOULD be indicated to the invoking application.
   </t>

   <section title='Unicode normalization' anchor="unicode-normal">
    <t>
     The Unicode Standard <xref target="UNIV4"/> defines various
     equivalences between sequences of characters for various
     purposes.  Unicode Standard Annex #15 <xref target="UTR15"/> defines
     various Normalization Forms for these equivalences, in
     particular Normalization Form KC (NFKC: Compatibility
     Decomposition followed by Canonical Composition). Since
     different Normalized Form unicode strings will have
     different UTF-8 representations, the only way to guarantee
     that template processors will produce the same URI is to
     require a common Normalized Form.
    </t>
    <t>
     The string values for the URI Template and template variables
     MUST be in NFKC and encoded as UTF-8 <xref target="RFC3629"/>
     prior to use in the template expansion process (US-ASCII is a
     proper subset of NFKC UTF-8).  The remaining sections defining
     the expansion process assume strings are in NFKC UTF-8.
    </t>
   </section>

   <section title='Literal expansion' anchor="literal-expansion">
    <t>
     The expansion for each literal character in the URI Template is
     either the character itself, if it is allowed anywhere in the URI
     syntax (&lt;unreserved&gt; / &lt;reserved&gt;), or the sequence of
     pct-encoded triplets corresponding to that character's octet(s) in
     NFKC UTF-8.
    </t>
   </section>

   <section title='Simple expansion: {var}' anchor="op-default">
    <t>
     The default expression type when no operator is given is
     simple expansion: the value of each defined variable is
     substituted in the order given, with each value separated
     by a comma character (",").
    </t>
    <figure><preamble>For example,</preamble><artwork>
  foo := "fred"

  "{foo}"        -&gt; "fred"
  "{foo,foo}"    -&gt; "fred,fred"
  "{bar,foo}"    -&gt; "fred"
  "{bar=wilma}"  -&gt; "wilma"
    </artwork></figure>
    <t>
     A variable that is undefined has no value and thus is
     excluded from the expansion.  If all of the variables are
     undefined, then the expression's expansion is the empty string.
    </t>
    <t>
     A variable defined as a single value is expanded by converting its
     value to a NFKC UTF-8 string, replacing any character within
     the string that is not in the unreserved set with its
     corresponding sequence of pct-encoded octets, applying any prefix
     or suffix modifier (<xref target="partial-values"/>), and then
     appending the result to the URI-reference (prefixed by a comma if
     this is not the first defined variable in the current expression).
    </t>
    <t>
     A variable defined as a list of values is expanded by converting
     each value to a NFKC UTF-8 string, replacing any character within
     each value string that is not in the unreserved set
     with its corresponding sequence of pct-encoded octets, joining the
     value strings in order as a single string of comma-separated values,
     applying any prefix or suffix modifier to the combined string, and
     then appending the result to the URI-reference (prefixed by a comma
     if this is not the first defined variable in the current expression).
     [Needs adjusting for plus explode modifier.]
    </t>
    <t>
     A variable defined as an associative array is expanded as a list
     of alternating key and value pairs, excluding any keys for which
     the corresponding value is undefined.
    </t>
    <t>
     A variable defined as a structure of component values is expanded
     as a list of the component values (excluding the component names)
     in the order implied by a preorder (depth-first) traversal of that
     structure, excluding any components that are undefined.
    </t>
   </section>

   <section title='Reserved expansion: {+var}' anchor="op-plus">
    <t>
     Reserved expansion is identical to simple expansion except that the
     substituted values may contain characters in the reserved set.
    </t>
    <figure><preamble>For example,</preamble><artwork>
  foo  := "That's right!"

  "{foo}"        -&gt; "That%27s%20right%21"
  "{+foo}"       -&gt; "That%27s%20right!"
  
  base := "http://example.com/home/"
  
  "{base}index"  -&gt; "http%3A%2F%2Fexample.com%2Fhome%2Findex"
  "{+base}index" -&gt; "http://example.com/home/index"
    </artwork></figure>
    <t>
     The same expansion process is followed as in <xref target="op-default"/>
     except that, instead of replacing any character within each value
     string that is not in the unreserved set with its corresponding
     sequence of pct-encoded octets, replace any character within each
     value string that is not in the set of unreserved or reserved
     characters with its corresponding sequence of pct-encoded octets.
    </t>
   </section>

   <section title='Path-style parameter expansion: {;var}' anchor="op-semicolon">
     <t>
      NOTE: ALL TEXT BELOW THIS POINT IS UNFINISHED AND MOSTLY OBSOLETE.
     </t>
    <t>
     If each variable is undefined or an empty list
     then substitute the value of arg, otherwise
     substitute the empty string.
    </t>
    <t>
     Example:
     <figure><artwork>
  foo := "fred"

  "{-neg|fred@example.org|foo}" -&gt; ""
  "{-neg|fred@example.org|bar}" -&gt; "fred@example.org"
     </artwork></figure>
    </t>
    <t>
     A variable defined as a list of values is substituted as a
     string of comma-separated values when no explode modifier
     is given.  If the "*" modifier is used, then each value is
     separated by the default delimiter used by the operator.
     If the "+" operator is used, then the variable name is
     prepended to the expansion list as if it were the initial
     value in the list.
    </t>
    <t>
     A variable defined as an associative array is substituted as
     a comma-separated list if no explode modifier is given or a
     sequence of default-delimited tuples if the "*" modifier is
     used.  If the "+" modifier is used, the values are substituted
     as in the "*" case, except that each key name is prefixed by
     the variable name and a ".", as in "name.key,value".
    </t>
    <t>
     When a variable containing component values is given without an
     explode modifier, the value of each defined component is
     substituted, separated by a comma (",") character, in the order
     indicated by the variable's schema or, if the schema is unknown,
     in the order provided by the variable's value.
    </t>
    <t>
     When an explode modifier is used with an operator that substitutes
     variables as key=value pairs, the key is determined as follows.
     If the modifier is an asterisk ("*"), then each "key" is the name
     of the component.  If the modifier is a plus ("+"), then each key
     is the variable name followed by a period (".") and the component
     name. In both cases, if the component names have a hierarchical
     structure, then the component subnames are also appended to the
     key, each separated by a period.
    </t>
    <t>
     When an explode modifier is used with the hierarchical ("/")
     operator, then the slash delimiter is substituted before each
     defined component's value if the modifier is "*", or before each
     tuple of component name and value (e.g., "/name,value") if the
     modifier is "+".
    </t>
   </section>

   <section title='Form-style parameter expansion: {?var}' anchor="op-question">
    <t>
     The prefix operator MUST only have one variable in
     its expression. More than one variable is an error condition.
     If the variable is undefined or an empty
     list then substitute the empty string. If the variable
     is a defined non-list then substitute the value of arg preceded
     by the value of the variable. If the variable is a defined list
     then substitute the concatenation of every list value preceded
     by the arg.
    </t>
    <t>
     Example:
     <figure><artwork>
  foo := "fred"
  bar := ["fee", "fi", "fo", "fum"]
  baz := []

  "{-prefix|/|foo}" -&gt; "/fred"
  "{-prefix|/|bar}" -&gt; "/fee/fi/fo/fum"
  "{-prefix|/|baz}" -&gt; ""
  "{-prefix|/|qux}" -&gt; ""
     </artwork></figure>
    </t>
    <t>
     A variable defined as a list of values is substituted as a
     string of comma-separated values when no explode modifier
     is given.  If the "*" modifier is used, then each value is
     separated by the default delimiter used by the operator.
     If the "+" operator is used, then the variable name is
     prepended to the expansion list as if it were the initial
     value in the list.
    </t>
    <t>
     A variable defined as an associative array is substituted as
     a comma-separated list if no explode modifier is given or a
     sequence of default-delimited tuples if the "*" modifier is
     used.  If the "+" modifier is used, the values are substituted
     as in the "*" case, except that each key name is prefixed by
     the variable name and a ".", as in "name.key,value".
    </t>
    <t>
     When a variable containing component values is given without an
     explode modifier, the value of each defined component is
     substituted, separated by a comma (",") character, in the order
     indicated by the variable's schema or, if the schema is unknown,
     in the order provided by the variable's value.
    </t>
    <t>
     When an explode modifier is used with an operator that substitutes
     variables as key=value pairs, the key is determined as follows.
     If the modifier is an asterisk ("*"), then each "key" is the name
     of the component.  If the modifier is a plus ("+"), then each key
     is the variable name followed by a period (".") and the component
     name. In both cases, if the component names have a hierarchical
     structure, then the component subnames are also appended to the
     key, each separated by a period.
    </t>
    <t>
     When an explode modifier is used with the hierarchical ("/")
     operator, then the slash delimiter is substituted before each
     defined component's value if the modifier is "*", or before each
     tuple of component name and value (e.g., "/name,value") if the
     modifier is "+".
    </t>
   </section>

   <section title='Hierarchical path expansion: {/var}' anchor="op-slash">
    <t>
     The prefix operator MUST only have one variable in
     its expression. More than one variable is an error condition.
     If the variable is undefined or an empty
     list then substitute the empty string. If the variable
     is a defined non-list then substitute the value of arg followed
     by the value of the variable. If the variable is a defined list
     then substitute the concatenation of every list value followed
     by the arg.
    </t>

    <t>
     Example:
     <figure><artwork>
  foo := "fred"
  bar := ["fee", "fi", "fo", "fum"]
  baz := []

  "{-suffix|/|foo}" -&gt; "fred/"
  "{-suffix|/|bar}" -&gt; "fee/fi/fo/fum/"
  "{-suffix|/|baz}" -&gt; ""
  "{-suffix|/|qux}" -&gt; ""
     </artwork></figure>
    </t>
   </section>

   <section title="Label expansion with dot-prefix: {.var}" anchor="op-dot">
    <t>
     The listjoin operator MUST have only one variable
     in its expression and that variable must be a list.
     More than one variable is an error.
     If the list is non-empty then substitute
     the concatenation of all the list members with intervening
     values of arg. If the list is empty or the variable is undefined them
     substitute the empty string.
    </t>
    <t>
     Example:
     <figure><artwork>
  foo := ["fred", "barney", "wilma"]
  bar := ["a", "", "c"]
  baz := ["betty"]
  qux := []

  "{-list|/|foo}" -&gt; "fred/barney/wilma"
  "{-list|/|bar}" -&gt; "a//c"
  "{-list|/|baz}" -&gt; "betty"
  "{-list|/|qux}" -&gt; ""
  "{-list|/|corge}" -&gt; ""
     </artwork></figure>
    </t>
   </section>
  </section>

  <section title="Examples" anchor="examples">
   <texttable anchor="example-table">
    <preamble>
     Given the following template variable names and values:
    </preamble>
    <ttcol>Name</ttcol>  <ttcol>Value</ttcol>
    <c>foo</c>     <c>\u03d3</c>
    <c>bar</c>     <c>fred</c>
    <c>baz</c>     <c>10,20,30</c>
    <c>qux</c>     <c>["10","20","30"]</c>
    <c>corge</c>     <c>[]</c>
    <c>grault</c>     <c></c>
    <c>garply</c>     <c>a/b/c</c>
    <c>waldo</c>     <c>ben &amp; jerrys</c>
    <c>fred</c>     <c>["fred", "", "wilma"]</c>
    <c>plugh</c>    <c>["\u017F\u0307", "\u0073\u0307"]</c>
    <c>1-a_b.c</c>  <c>200</c>
   </texttable>
   <t>
    The variable 'foo' is the unicode character
    GREEK UPSILON WITH ACUTE AND HOOK SYMBOL.
    This character was chosen because it is one of only three characters
    that has a different normal form for each of the four normalization
    forms (NFC, NFD, NFKC, NFKD).
    The name 'xyzzy' has not been defined,
    the value of 'grault' is the empty string.
    The variables qux, corge, fred, and plugh are lists.
   </t>

   <t>The following URI Templates will be expanded as shown:</t>
   <t>    ----</t>
   <figure><artwork>
  http://example.org/?q={bar}
  http://example.org/?q=fred

  /{xyzzy}
  /

  http://example.org/?{-join|&amp;|foo,bar,xyzzy,baz}
  http://example.org/?foo=%CE%8E&amp;bar=fred&amp;baz=10%2C20%2C30

  http://example.org/?d={-list|,|qux}
  http://example.org/?d=10,20,30

  http://example.org/?d={-list|&amp;d=|qux}
  http://example.org/?d=10&amp;d=20&amp;d=30

  http://example.org/{bar}{bar}/{garply}
  http://example.org/fredfred/a%2Fb%2Fc

  http://example.org/{bar}{-prefix|/|fred}
  http://example.org/fred/fred//wilma

  {-neg|:|corge}{-suffix|:|plugh}
  :%E1%B9%A1:%E1%B9%A1:

  ../{waldo}/
  ../ben%20%26%20jerrys/

  telnet:192.0.2.16{-opt|:80|grault}
  telnet:192.0.2.16:80

  :{1-a_b.c}:
  :200:
   </artwork></figure>
   <t>    ----</t>
  </section>

  <section title="Security Considerations">
   <t>
    A URI Template does not contain active or executable content. Other
    security considerations are the same as those for URIs, see section 7
    of <xref target="RFC3986"/>.
   </t>
  </section>

  <section title="IANA Considerations" anchor="iana">
   <t>
    No IANA actions are required by this document.
   </t>
  </section>

  <section title="Acknowledgments" anchor="ack">
   <t>
    The following people made significant contributions to this
    specification: Mike Burrows, Michaeljohn Clement, DeWitt Clinton,
    John Cowan, James H. Manger, and James Snell.
   </t>
  </section>
 </middle>

 <back>
  <references title='Normative References'>
   &ASCII;
   &UNIV4;
   &UTR15;
   &rfc2119;
   &rfc2978;
   &rfc3986;
   &rfc3987;
   &rfc3629;
   &rfc5234;
  </references>

  <section title="Example URI Template Parser" anchor="parser">
   <t>
    Parsing a valid URI Template expression does not require
    building a parser from the given ABNF. Instead, the set of allowed
    characters in each part of URI Template expression has been
    chosen to avoid complex parsing, and breaking an expression into
    its component parts can be achieved by a series of splits
    of the character string.
   </t>
   <t>
    Here is example Python code that parses a URI Template
    expression and returns the operator, argument, and
    variables as a tuple. The variables are returned
    as a dictionary of variable names mapped to their
    default values. If no default is given then the
    name maps to None.
   </t>
   <figure><artwork>
  def parse_expression(expression):
      if "|" in expression:
          (op, arg, vars_) = expression.split("|")
          op = op[1:]
      else:
          (op, arg, vars_) = (None, None, expression)
      vars_ = vars_.split(",")

      variables = {}
      for var in vars_:
          if "=" in var:
              (varname, vardefault) = var.split("=")
          else:
              (varname, vardefault) = (var, None)
          variables[varname] = vardefault

      return (op, arg, variables)
   </artwork></figure>
   <t>
    And here is an example of the parse_expression() function being
    used.
   </t>
   <figure><artwork>
  &gt;&gt;&gt; parse_expression("-join|&amp;|a,b,c=1")
  ('join', '&amp;', {'a': None, 'c': '1', 'b': None})
  &gt;&gt;&gt; parse_expression("c=1")
  (None, None, {'c': '1'})
   </artwork></figure>
  </section>

  <section title="Revision History (to be removed by RFC Editor)" anchor="revisions">
   <t>04 - Changed the operator syntax to a single character that is
      analogous to its reserved role within the URI generic syntax,
      resulting in templates that are far more readable for the common
      cases. Added value modifiers for prefix and suffix expansion.
      Added explode modifiers to allow expansion of complex variables
      and lists according to (external) variable types or schema.
      Replaced use of "expansion" with "expression", since expansion
      is traditionally used to refer to the result after expanding
      a macro (not the macro itself). Made applicable to any hypertext
      reference string, such that the process for template expansion
      also includes transforming the surrounding string into a proper
      URI-reference rather than assuming it is already in absolute URI form.
      Rewrote the text accordingly.</t>
   <t>03 - Added more examples. Introduced error conditions and defined
      their handling. Changed listjoin to list. Changed -append to -suffix,
      and allowed -prefix and -suffix to accept list variables. Clarified
      the handling of unicode.</t>
   <t>02 - Added operators and came up with coherent
      percent-encoding and reserved character story.
      Added large examples section which is extracted
      and tested against the implementation.
   </t>
   <t>01
   </t>
   <t>00 - Initial Revision.
   </t>
  </section>
 </back>
</rfc>
