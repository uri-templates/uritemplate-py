<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
 <!ENTITY rfc2119 SYSTEM 'bibxml/reference.RFC.2119.xml'>
 <!ENTITY rfc3986 SYSTEM 'bibxml/reference.RFC.3986.xml'>
 <!ENTITY rfc5234 SYSTEM 'bibxml/reference.RFC.5234.xml'>
 <!ENTITY rfc2978 SYSTEM 'bibxml/reference.RFC.2978.xml'>
 <!ENTITY rfc3629 SYSTEM 'bibxml/reference.RFC.3629.xml'>
 <!ENTITY ASCII   SYSTEM 'bibxml/_reference.ANSI.X3-4.1986.xml'>
 <!ENTITY UNIV4   SYSTEM 'bibxml/univ4.xml'>
 <!ENTITY UTR15   SYSTEM 'bibxml/utr15.xml'>
 ]>

<!--<?xml-stylesheet type='text/xsl' href='rfc2629.xslt'/ ?>-->

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="yes" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes" ?>
<?rfc tocdepth="3" ?>
<!--
 1. Update the docName
 2. Update the date
 3. Update the Revision History.
-->

<rfc category="std" ipr="full3978" docName="draft-gregorio-uritemplate-03">
 <front>
  <title>URI Template</title>

  <author initials='J.C.' surname="Gregorio" fullname='Joe Gregorio' role="editor">
   <organization>Google</organization>
   <address>
    <email>joe@bitworking.org</email>
    <uri>http://bitworking.org/</uri>
   </address>
  </author>

  <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
   <organization abbrev="Day Software">Day Software</organization>
   <address>
    <email>fielding@gbiv.com</email>
    <uri>http://roy.gbiv.com/</uri>
   </address>
  </author>

  <author initials='M.H.' surname="Hadley" fullname='Marc Hadley' role="editor">
   <organization>Sun Microsystems</organization>
   <address>
    <email>Marc.Hadley@sun.com</email>
    <uri>http://sun.com/</uri>
   </address>
  </author>

  <author initials='M.N.' surname="Nottingham" fullname='Mark Nottingham' role="editor">
   <organization></organization>
   <address>
    <email>mnot@pobox.com</email>
    <uri>http://mnot.net/</uri>
   </address>
  </author>

  <author initials='D.O.' surname="Orchard" fullname='David Orchard'>
   <organization>BEA Systems, Inc.</organization>
   <address>
    <email>dorchard@bea.com</email>
    <uri>http://bea.com/</uri>
   </address>
  </author>

  <date day="08" month="Jul" year="2009"/>
  <abstract>
   <t>
    A URI Template is a compact sequence of characters
    for describing a range of Uniform Resource Identifiers
    through variable substitution.
    This specification defines the URI Template
    syntax and the process for expanding a URI Template into a
    URI, along with guidelines for the
    use of URI Templates on the Internet.
   </t>
  </abstract>

  <note title="Editorial Note (to be removed by RFC Editor)">
   <t>
    To provide feedback on this Internet-Draft, join the
    <eref target="http://lists.w3.org/Archives/Public/uri/">W3C URI
    mailing list (http://lists.w3.org/Archives/Public/uri/)</eref>.
   </t>
  </note>
 </front>

 <middle>
  <section title="Introduction">
   <t>
    A Uniform Resource Identifier (URI) <xref target="RFC3986"/>
    is often used to identify a specific resource within a common
    space of similar resources. For example, personal web spaces
    are often delegated using a common pattern, such as
   </t>
   <figure><artwork>
  http://example.com/users/fred/
  http://example.com/users/mark/
   </artwork></figure>
   <t>
    or a set of dictionary entries might be grouped in a hierarchy
    by the first letter of the term, as in
   </t>
   <figure><artwork>
  http://example.com/dictionary/c/cat
  http://example.com/dictionary/d/dog
   </artwork></figure>
   <t>
    or a service interface might be invoked with various user input
    in a common pattern, as in
   </t>
   <figure><artwork>
  http://example.com/search?q=cat&amp;lang=en
  http://example.com/search?q=dog&amp;lang=fr
   </artwork></figure>
   <t>
    URI Templates provide a mechanism for abstracting a space of
    resource identifiers such that the variable parts can be easily
    identified and described.  URI templates can have many uses,
    including discovery of available services, configuring resource
    mappings, defining computed links, specifying interfaces, and
    other forms of programmatic interaction with resources.
    For example, the above resources could be described by the
    following URI templates:
   </t>
   <figure><artwork>
  http://example.com/users/{username}/
  http://example.com/dictionary/{term:1}/{term}
  http://example.com/search{?q,lang}
   </artwork></figure>
   <t>
    A URI Template provides both a structural description of a URI
    space and, when variable values are provided, a simple instruction
    on how to construct URIs corresponding to each of those values.
    A URI Template is transformed into a URI by replacing each
    delimited expression with its value as defined by the
    expression type and the values of variables named within the
    expression.  The expression types range from simple value
    substitution to multiple key=value lists.  The substitutions
    are based on the URI generic syntax, allowing an implementation
    to process any URI Template without knowing the scheme-specific
    requirements of every possible resulting URI.
   </t>
   <t>
    Since a URI Template describes a superset of the identifiers,
    there is no implication that every possible substitution for
    each delimited variable expression corresponds to a URI of an
    existing resource.  Our expectation is that an application
    constructing URIs according to the template will be provided
    with an appropriate set of values for the variables being
    substituted and will be able to cope with any errors that might
    occur should the resulting URI be inaccessible.
   </t>

   <section title="Overview">
    <t>
     A URI Template consists of a string of characters with zero or
     more embedded variable expressions, each expression being
     delimited by a matching pair of braces ('{', '}').
     Each expression contains an optional operator that indicates
     the expression type (defaulting to simple value substitution)
     and a list of one or more comma-separated variable names with
     optional modifiers.  The optional modifiers allow splitting the
     variable value into a substring (prefix or suffix), providing a
     default value for when the variable is empty, or indicating
     that the value be processed as a list or associative array
     of strings instead of a single string value.
    </t>
    <t>
     The process of URI Template expansion is to scan the
     reference string from left to right and replace each
     expression with the result of applying the operator to
     the values of each variable in the list.  The result of
     expanding all template expressions is a URI-reference,
     as defined by <xref target="RFC3986"/>.  The process is
     therefore similar to a macro language with a fixed set
     of macro definitions. For example, given the following
     URI Template:
    </t>
    <figure><artwork>
  http://www.example.com/users/{userid}
    </artwork></figure>
    <t>
     If the variable is assigned a value of
    </t>
    <figure><artwork>
  userid := "fred"
    </artwork></figure>
    <t>
     then the expansion of the URI Template will be:
    </t>
    <figure><artwork>
  http://www.example.com/users/fred
    </artwork></figure>
    <t>
     Here is an example that constructs a query
     from multiple variables:
    </t>
    <figure><artwork>
  http://www.example.com/foo{?query,number}
    </artwork></figure>
    <t>
     If the variables have the values
    </t>
    <figure><artwork>
  query  := "mycelium"
  number := 100
    </artwork></figure>
    <t>
     then the expansion of the URI Template is:
    </t>
    <figure><artwork>
  http://www.example.com/foo?query=mycelium&amp;number=100
    </artwork></figure>
    <t>
     Each template expression describes in a machine
     readable manner how the URI is to be constructed.
    </t>
    <figure><artwork>
  http://www.example.com/foo{?query,number}
                            \_____________/
                               |
                               |
                      Join 'var=value' for each variable
                      in ['query', 'number'] with '&amp;'.
    </artwork></figure>
    <t>
     The following table summarizes each type of template
     expression by its associated operator and cross-references
     the section of this document that defines the operator and
     its specific expansion process.  The example expansions are
     based on the following variables and values:
    </t>
    <figure><artwork>
   var   = "value";
   hello = "Hello World!";
   undef = null;
   empty = "";
   list  = [ "val1", "val2", "val3" ];
   keys  = [ "key1", "val1", "key2", "val2" ];
   path  = "/foo/bar"
   x     = "1024";
   y     = "768";

.-----------------------------------------------------------------.
| Sec | Op  | Description                                         |
|     |     |    Example Template       Expansion                 |
|-----+-----+-----------------------------------------------------|
| X.1 |     | Encoded substitution with comma-separated values    |
|     |     |                                                     |
|     |     |    {var}                  value                     |
|     |     |    {hello}                Hello%20World%21          |
|     |     |    {path}/here            %2Ffoo%2Fbar/here         |
|     |     |    {x,y}                  1024,768                  |
|     |     |    {var=default}          value                     |
|     |     |    {undef=default}        default                   |
|     |     |    {var:3}                val                       |
|     |     |    {var:-3}               ue                        |
|     |     |                                                     |
|-----+-----+-----------------------------------------------------|
| X.2 |  +  | Unencoded substitution with comma-separated values  |
|     |     |                                                     |
|     |     |    {+var}                 value                     |
|     |     |    {+hello}               Hello World!              |
|     |     |    {+path}/here           /foo/bar/here             |
|     |     |    {+path,x}/here         /foo/bar,1024/here        |
|     |     |    {+path}{x}/here        /foo/bar1024/here         |
|     |     |    {+empty}/here          /here                     |
|     |     |                                                     |
|-----+-----+-----------------------------------------------------|
| X.3 |  ;  | Encoded path segment parameters, semicolon-prefixed |
|     |     |                                                     |
|     |     |    {;x,y}                 ;x=1024;y=768             |
|     |     |    {;x,y,empty}           ;x=1024;y=768;empty       |
|     |     |    {;x,y,undef}           ;x=1024;y=768             |
|     |     |    {;%keys}               ;key1=val1;key2=val2      |
|     |     |                                                     |
|-----+-----+-----------------------------------------------------|
| X.4 |  ?  | Encoded query parameters, ampersand-separated       |
|     |     |                                                     |
|     |     |    {?x,y}                 ?x=1024&amp;y=768             |
|     |     |    {?x,y,empty}           ?x=1024&amp;y=768&amp;empty=      |
|     |     |    {?x,y,undef}           ?x=1024&amp;y=768             |
|     |     |    {?list}                ?list1=val1,val2,val3     |
|     |     |    {?%keys}               ?key1=val1&amp;key2=val2      |
|     |     |    {?@list}  ?list1=val1&amp;list2=val2&amp;list3=val3      |
|     |     |                                                     |
|-----+-----+-----------------------------------------------------|
| X.5 |  /  | Encoded path segments, slash-separated              |
|     |     |                                                     |
|     |     |    {/var}                 /value                    |
|     |     |    {/list}                /val1/val2/val3           |
|     |     |    {/list,x}              /val1/val2/val3/1024      |
|     |     |                                                     |
|-----+-----+-----------------------------------------------------|
    </artwork></figure>
    <t>
     The important thing to note is that compound values are only
     interesting when templates are embedded within computer language
     processing, so we could easily allow such things to be language
     specific by reserving non-alphanumeric prefixes on variable names
     for that purpose.
    </t>
    <t>
     I think the above covers all of the common cases without making
     the uncommon cases impossible.  The common case is that the delimiters
     (";", "?", and "/") are omitted when none of the listed variables are
     defined, which matches good URI practice.  Likewise, the substitution
     handler for ";" (path parameters) will omit the "=" when its value is empty,
     whereas the handler for "?" (form queries) will not omit the "=".
     Multiple variables and list values have their values joined with ","
     if there is no predefined joining mechanism for the operator.
    </t>
    <t>
     I think this mechanism is simple and readable when used with simple
     examples because the single-character operators match the URI generic
     syntax delimiters.  Only one operator inserts unencoded values; all
     of the others encode any characters other than unreserved.
    </t>
    <t>
     The mechanism does become harder to read when we do very unusual
     things and add all the bells and whistles, like
    </t>
    <figure><artwork>
{var,undef,empty,list}    value,,val1,val2,val3
{/var:3,undef,list,empty} /val/val1/val2/val3/
{;var,undef,empty,list}   ;var=value;empty;list=val1,val2,val3
{?var,undef,empty,list}   ?var=value&amp;empty=&amp;list=val1,val2,val3
{?var,undef,empty,@list}  ?var=value&amp;empty=&amp;list1=val1&amp;list2=val2&amp;list3=val3
{?var,undef,empty,%keys}  ?var=value&amp;empty=&amp;key1=val1&amp;key2=val2&amp;key3=val3
    </artwork></figure>
    <t>
     but we don't need to care if complex cases are hard to read.
    </t>
   </section>

   <section title="Design Considerations">
    <t>
     The URI Template syntax has been designed to carefully balance
     the need for a powerful substitution mechanism with ease
     of implementation and security. The syntax is designed
     to be easy to parse while at the same time providing
     enough flexibility to express many common templating
     scenarios.
    </t>
    <t>
     Mechanisms similar to URI Templates have been defined within
     several specifications, including WSDL, WADL and OpenSearch.
     This specification extends and formally defines the syntax so
     that URI Templates can be used consistently across multiple
     Internet applications and within Internet message fields.
    </t>
    <t>
     The final design consideration was control over
     the placement of reserved characters in the
     URI generated from a URI Template. The reserved characters
     in a URI Template can only appear in the non-expression
     text, or in the argument to an operator, both locations
     are dictated by the URI Template author. Given
     the percent-encoding rules for variable values
     this means that the source of all structure, i.e
     reserved characters, in a URI generated from a
     URI Template is decided by the URI Template author.
    </t>
   </section>

   <section title="Applicability">
    <t>
     While URI Templates use a notation that is similar to some URI path
     matching notations in web frameworks, URI Templates were not designed
     for that use case, nor are they appropriate for that purpose.
     URI Templates are not URIs, they do not identify an abstract or physical
     resource, they are not to be treated like URIs,
     nor should not be used in places where a URI would be expected.
    </t>
   </section>

   <section title="Notational Conventions">
    <section title="Terminology">
     <t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
      "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",
      "MAY", and "OPTIONAL" in this document are to be
      interpreted as described in <xref target="RFC2119"/>.
     </t>
     <t>
      This specification uses the terms "character" and "coded
      character set" in accordance with the definitions provided
      in <xref target="RFC2978"/>, and "character encoding" in
      place of what
      <xref target="RFC2978"/> refers to as a "charset".
     </t>
     <t>
      In addition, the following terms are defined:
      <list style="symbols">
       <t>
        template expression - The text between '{' and '}', including the
        enclosing brackets.
       </t>
       <t>
        template expansion - The result of processing a template expression
        by replacing it with the variable values as defined by the
        expression type.
       </t>
       <t>
        template processor - A program or library that converts a URI
        Template into a URI.
       </t>
      </list>
     </t>
    </section>

    <section title="ABNF and Character Encoding">
     <t>
      This specification uses the Augmented Backus-Naur Form
      (ABNF) notation of <xref target="RFC5234"/>, including
      the following core ABNF syntax rules defined by that
      specification: ALPHA (letters) and DIGIT (decimal
      digits).  See <xref target="RFC3986"/> for the
      definitions of the URI-reference, pct-encoded,
      reserved, and unreserved rules.
     </t>
     <t>
      A URI Template is a sequence of characters, and has the same
      issues as URIs with regard to codepoints and character sets.
      That is, URI Template characters are frequently encoded
      as octets for transport or presentation.  This specification
      does not mandate any particular character encoding for
      mapping between URI characters and the octets used to store
      or transmit those characters.  When a URI appears in a
      protocol element, the character encoding is defined by that
      protocol; without such a definition, a URI is assumed to be
      in the same character encoding as the surrounding text.
     </t>
     <t>
      The ABNF notation defines its terminal values to be
      non-negative integers (codepoints) based on the US-ASCII
      coded character set <xref target="ASCII"/>.  Because a URI is a sequence of
      characters, we must invert that relation in order to
      understand the URI syntax.  Therefore, the integer values
      used by the ABNF must be mapped back to their corresponding
      characters via US-ASCII in order to complete the syntax
      rules.
     </t>
    </section>
   </section>
  </section>

  <section title="URI Template Syntax">
   <t>
    A URI Template is a sequence of characters that contains any number of
    embedded template expressions, see <xref target="expressions"/>.
    Each expression references one or
    more variables whose values are used when determining the
    substitution value for an expression.  A URI Template becomes a
    URI when all the template expressions are substituted with their
    values (see <xref target="evaluating"/>). The generated
    URI will be a URI-reference, i.e. either an absolute
    URI or a relative reference.
   </t>

   <section title="Expressions" anchor="expressions">
    <t>
     Template expressions are the parameterized components of a URI Template.
     A template expression MUST match the 'expression' rule.
    </t>
    <t>
     The ABNF is something like
    </t>
    <figure><artwork>
  expression    = "{" [ operator ] variable-list "}"
  operator      = "/" / "+" / ";" / "?" / op-reserve
  variable-list =  varspec *( "," varspec )
  varspec       =  [ vartype ] varname [ ":" substring ] [ "=" default ]
  vartype       = "@" / "%"
  varname       = 1*varchar
  substring     = [ "-" ] 1*DIGIT
  default       = *( unreserved / reserved - "," )
  op-reserve    = "!" / "*" / "="
  locals        = "$" / "(" / ")"
  braces        = "{" / "}"
  varchar       = &lt; any character except reserved / braces &gt;
  
  reserved    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
              / "!" / "$" / "&amp;" / "'" / "(" / ")"
              / "*" / "+" / "," / ";" / "="
  
    </artwork></figure>
   </section>

   <section title="Variables" anchor="variables">
    <t>
     Each expression contains a list of zero or more variables.
     Any of the variables can be prefixed.  Any of the values
     can have a default when undefined.
    </t>
    <t>
     Every variable is a Unicode string.
    </t>
    <t>
     A template expression MAY reference variables that are unknown
     to the template processor. Those variables are 'undefined'
     and template expansion takes into consideration 'undefined' variables.
     Conversely, every variable that the template processor knows about
     is considered 'defined'.
    </t>
    <t>
     A variable that contains a string of length zero MUST NOT be
     considered 'undefined' by the template processor.
     A list variable that contains no members, that is of zero length, MUST NOT
     be considered 'undefined' by the template processor.
    </t>
    <t>
     Beyond the scope of this
     specification is the allowable programming constructs
     that can be used for a list variable. For example, a Python
     implementation might allow only built-in list types, or
     it may allow any iterable to be used as the source for a
     list variable.
    </t>
    <t>
     Some variables may be supplied with default values. The default
     value must come from ( unreserved / pct-encoded ). Note that
     there is no notation for supplying default values to list variables.
    </t>
    <t>
     A variable may appear in more than one expression in a
     URI Template. The value used for that variable MUST
     remain the same for every template expression when
     converting a URI Template into a URI.
    </t>
   </section>
  </section>

  <section title="URI Template Expansion" anchor="evaluating">
   <t>
    Template expansion is the process of turning
    a URI Template into a URI given definitions
    for the variables used in the template. Substitution
    replaces each expression with its calculated value.
    A template processor take two inputs, a URI Template and
    a set of variables, and returns a URI-reference.
   </t>
   <t>
    Before substitution the template processor MUST convert
    every variable value into a sequence of characters in
    ( unreserved / pct-encoded ).
    The template processor does that using the following algorithm:
    The template processor normalizes the string using NFKC, converts it to
    UTF-8 <xref target="RFC3629"/>, and then
    every octet of the UTF-8 string that falls outside of
    ( unreserved ) MUST be percent-encoded, as
    per <xref target="RFC3986"/>, section 2.1.
    For variables that are lists, the above algorithm is applied
    to each value in the list.
   </t>
   <t>
    The Unicode Standard <xref target="UNIV4"/> defines various
    equivalences between sequences of characters for various
    purposes.  Unicode Standard Annex #15 <xref target="UTR15"/> defines
    various Normalization Forms for these equivalences, in
    particular Normalization Form KC (NFKC, Compatibility
    Decomposition, followed by Canonical Composition). Since
    different Normalized Forms unicode strings will have
    different UTF-8 representations the only way to guarantee
    that template processors will produce the same URI is to
    require a common Normalized Form.
   </t>
   <t>
    Requiring that all characters outside of ( unreserved ) be
    percent encoded means that the only characters outside of
    ( unreserved ) that will appear in the generated URI-reference
    will come from outside the template expressions in the URI Template or
    from the argument of a template expression. This means that the
    designer of the URI Template determines the placement of reserved
    characters in the resulting URI, and thus the structure of the
    resulting generated URI-reference.
   </t>
   <t>
    If the expression is an operator then the substitution value
    is determined by the given operator. Each operator
    works only on the variables that are defined within
    their expression.
   </t>
   <t>
    The result of substitution
    MUST match the URI-reference rule and SHOULD also match
    any known rules for the scheme of the resulting URI.
   </t>
   <t>
    If a template processor encounters an operator that it does not
    understand then it MUST fail and MUST NOT produce a URI from
    the URI Template. The list of operators that a template processor
    knows is not constrained by this specification, that is, later
    specifications may add new operators.
   </t>
   <t>
    Every expression consists of either a variable ('var') or
    an operator expression ('operator'), and the rules for how
    to expand each of these is given below. For every expression
    a template MUST have at least one variable name in the
    template expression. It is an error if no variables are supplied.
    All of the variables supplied to a template expression MAY be undefined
    and the expansion rules below specify how to process the template
    expression in that situation.
   </t>
   <t>
    It is extremely easy to
    parse and perform the substitutions within a single pass loop.
   </t>

   <section title="('var') substitution" anchor="var">
    <t>
     In a variable ('var')
     expansion, if the variable is defined then
     substitute the value of the variable, otherwise
     substitute the default value. If no default value is
     given then substitute with the empty string.
    </t>
    <t>
     Example:
     <figure><artwork>
  foo := "fred"

  "{foo}"        -> "fred"
  "{bar=wilma}"  -> "wilma"
  "{baz}"        -> ""
     </artwork></figure>
    </t>
   </section>

   <section title="The 'opt' operator" anchor="opt">
    <t>
     If each variable is undefined or an empty list
     then substitute the empty string, otherwise
     substitute the value of 'arg'.
    </t>
    <t>
     Example:
     <figure><artwork>
  foo := "fred"

  "{-opt|fred@example.org|foo}" -> "fred@example.org"
  "{-opt|fred@example.org|bar}" -> ""
     </artwork></figure>
    </t>
   </section>

   <section title="The 'neg' operator" anchor="neg">
    <t>
     If each variable is undefined or an empty list
     then substitute the value of arg, otherwise
     substitute the empty string.
    </t>
    <t>
     Example:
     <figure><artwork>
  foo := "fred"

  "{-neg|fred@example.org|foo}" -> ""
  "{-neg|fred@example.org|bar}" -> "fred@example.org"
     </artwork></figure>
    </t>
   </section>

   <section title="The 'prefix' operator" anchor="prefix">
    <t>
     The prefix operator MUST only have one variable in
     its expression. More than one variable is an error condition.
     If the variable is undefined or an empty
     list then substitute the empty string. If the variable
     is a defined non-list then substitute the value of arg preceded
     by the value of the variable. If the variable is a defined list
     then substitute the concatenation of every list value preceded
     by the arg.
    </t>
    <t>
     Example:
     <figure><artwork>
  foo := "fred"
  bar := ["fee", "fi", "fo", "fum"]
  baz := []

  "{-prefix|/|foo}" -> "/fred"
  "{-prefix|/|bar}" -> "/fee/fi/fo/fum"
  "{-prefix|/|baz}" -> ""
  "{-prefix|/|qux}" -> ""
     </artwork></figure>
    </t>
   </section>

   <section title="The 'suffix' operator" anchor="append">
    <t>
     The prefix operator MUST only have one variable in
     its expression. More than one variable is an error condition.
     If the variable is undefined or an empty
     list then substitute the empty string. If the variable
     is a defined non-list then substitute the value of arg followed
     by the value of the variable. If the variable is a defined list
     then substitute the concatenation of every list value followed
     by the arg.
    </t>

    <t>
     Example:
     <figure><artwork>
  foo := "fred"
  bar := ["fee", "fi", "fo", "fum"]
  baz := []

  "{-suffix|/|foo}" -> "fred/"
  "{-suffix|/|bar}" -> "fee/fi/fo/fum/"
  "{-suffix|/|baz}" -> ""
  "{-suffix|/|qux}" -> ""
     </artwork></figure>
    </t>
   </section>

   <section title="The 'join' operator" anchor="join">
    <t>
     Supplying a list variable to the join operator
     is an error. For each variable that is defined and non-empty
     create a key=value string that is the concatenation
     of the variable name, "=", and the
     variable value. Concatenate more than one key=value
     string with intervening values of arg to
     create the substitution value. The order of variables
     MUST be preserved during substitution.
    </t>
    <t>
     Example:
     <figure><artwork>
  foo := "fred"
  bar := "barney"
  baz := ""

  "{-join|&amp;|foo,bar,baz,qux}" -> "foo=fred&amp;bar=barney&amp;baz="
  "{-join|&amp;|bar}" -> "bar=barney"
  "{-join|&amp;|qux}" -> ""
     </artwork></figure>
    </t>
   </section>

   <section title="The 'list' operator" anchor="list">
    <t>
     The listjoin operator MUST have only one variable
     in its expression and that variable must be a list.
     More than one variable is an error.
     If the list is non-empty then substitute
     the concatenation of all the list members with intervening
     values of arg. If the list is empty or the variable is undefined them
     substitute the empty string.
    </t>
    <t>
     Example:
     <figure><artwork>
  foo := ["fred", "barney", "wilma"]
  bar := ["a", "", "c"]
  baz := ["betty"]
  qux := []

  "{-list|/|foo}" -> "fred/barney/wilma"
  "{-list|/|bar}" -> "a//c"
  "{-list|/|baz}" -> "betty"
  "{-list|/|qux}" -> ""
  "{-list|/|corge}" -> ""
     </artwork></figure>
    </t>
   </section>
  </section>

  <section title="Error Handling" anchor="error">
   <t>
    During template substitution error conditions may arise.
    The exact circumstances for those errors are described in
    <xref target="evaluating"/>. When an error occurs the
    template processor MUST NOT return a URI. It is language
    specific and beyond the scope of this document how the
    template processor signals that an error has occurred and that
    a URI will not be generated from the template.
   </t>
  </section>

  <section title="Examples" anchor="examples">
   <texttable anchor="example-table">
    <preamble>
     Given the following template variable names and values:
    </preamble>
    <ttcol>Name</ttcol>  <ttcol>Value</ttcol>
    <c>foo</c>     <c>\u03d3</c>
    <c>bar</c>     <c>fred</c>
    <c>baz</c>     <c>10,20,30</c>
    <c>qux</c>     <c>["10","20","30"]</c>
    <c>corge</c>     <c>[]</c>
    <c>grault</c>     <c></c>
    <c>garply</c>     <c>a/b/c</c>
    <c>waldo</c>     <c>ben &amp; jerrys</c>
    <c>fred</c>     <c>["fred", "", "wilma"]</c>
    <c>plugh</c>    <c>["\u017F\u0307", "\u0073\u0307"]</c>
    <c>1-a_b.c</c>  <c>200</c>
   </texttable>
   <t>
    The variable 'foo' is the unicode character
    GREEK UPSILON WITH ACUTE AND HOOK SYMBOL.
    This character was chosen because it is one of only three characters
    that has a different normal form for each of the four normalization
    forms (NFC, NFD, NFKC, NFKD).
    The name 'xyzzy' has not been defined,
    the value of 'grault' is the empty string.
    The variables qux, corge, fred, and plugh are lists.
   </t>

   <t>The following URI Templates will be expanded as shown:</t>
   <t>    ----</t>
   <figure><artwork>
  http://example.org/?q={bar}
  http://example.org/?q=fred

  /{xyzzy}
  /

  http://example.org/?{-join|&amp;|foo,bar,xyzzy,baz}
  http://example.org/?foo=%CE%8E&amp;bar=fred&amp;baz=10%2C20%2C30

  http://example.org/?d={-list|,|qux}
  http://example.org/?d=10,20,30

  http://example.org/?d={-list|&amp;d=|qux}
  http://example.org/?d=10&amp;d=20&amp;d=30

  http://example.org/{bar}{bar}/{garply}
  http://example.org/fredfred/a%2Fb%2Fc

  http://example.org/{bar}{-prefix|/|fred}
  http://example.org/fred/fred//wilma

  {-neg|:|corge}{-suffix|:|plugh}
  :%E1%B9%A1:%E1%B9%A1:

  ../{waldo}/
  ../ben%20%26%20jerrys/

  telnet:192.0.2.16{-opt|:80|grault}
  telnet:192.0.2.16:80

  :{1-a_b.c}:
  :200:
   </artwork></figure>
   <t>    ----</t>
  </section>

  <section title="Security Considerations">
   <t>
    A URI Template does not contain active or executable content. Other
    security considerations are the same as those for URIs, see section 7
    of <xref target="RFC3986"/>.
   </t>
  </section>

  <section title="IANA Considerations" anchor="iana">
   <t>
    No IANA actions are required by this document.
   </t>
  </section>

  <section title="Acknowledgments" anchor="ack">
   <t>
    The following people made significant contributions to this
    specification: Michaeljohn Clement, DeWitt Clinton, John Cowan,
    James H. Manger, and James Snell.
   </t>
  </section>
 </middle>

 <back>
  <references title='Normative References'>
   &ASCII;
   &UNIV4;
   &UTR15;
   &rfc2119;
   &rfc2978;
   &rfc3986;
   &rfc3629;
   &rfc5234;
  </references>

  <section title="Example URI Template Parser" anchor="parser">
   <t>
    Parsing a valid URI Template expression does not require
    building a parser from the given ABNF. Instead, the set of allowed
    characters in each part of URI Template expression has been
    chosen to avoid complex parsing, and breaking an expression into
    its component parts can be achieved by a series of splits
    of the character string.
   </t>
   <t>
    Here is example Python code that parses a URI Template
    expression and returns the operator, argument, and
    variables as a tuple. The variables are returned
    as a dictionary of variable names mapped to their
    default values. If no default is given then the
    name maps to None.
   </t>
   <figure><artwork>
  def parse_expression(expression):
      if "|" in expression:
          (op, arg, vars_) = expression.split("|")
          op = op[1:]
      else:
          (op, arg, vars_) = (None, None, expression)
      vars_ = vars_.split(",")

      variables = {}
      for var in vars_:
          if "=" in var:
              (varname, vardefault) = var.split("=")
          else:
              (varname, vardefault) = (var, None)
          variables[varname] = vardefault

      return (op, arg, variables)
   </artwork></figure>
   <t>
    And here is an example of the parse_expression() function being
    used.
   </t>
   <figure><artwork>
  &gt;&gt;&gt; parse_expression("-join|&amp;|a,b,c=1")
  ('join', '&amp;', {'a': None, 'c': '1', 'b': None})
  &gt;&gt;&gt; parse_expression("c=1")
  (None, None, {'c': '1'})
   </artwork></figure>
  </section>

  <section title="Revision History (to be removed by RFC Editor)" anchor="revisions">
   <t>04 - Changed the operator syntax to a single character that is
      analogous to its reserved role within the URI generic syntax,
      resulting in templates that are far more readable for the common
      cases. Replaced use of "expansion" with "expression", since expansion
      is traditionally used to refer to the result after expanding
      a macro (not the macro itself). Made applicable to any hypertext
      reference string, such that the process for template expansion
      also includes transforming the surrounding string into a proper
      URI-reference rather than assuming it is already in absolute URI form.
      Rewrote the text accordingly.</t>
   <t>03 - Added more examples. Introduced error conditions and defined
      their handling. Changed listjoin to list. Changed -append to -suffix,
      and allowed -prefix and -suffix to accept list variables. Clarified
      the handling of unicode.</t>
   <t>02 - Added operators and came up with coherent
      percent-encoding and reserved character story.
      Added large examples section which is extracted
      and tested against the implementation.
   </t>
   <t>01
   </t>
   <t>00 - Initial Revision.
   </t>
  </section>
 </back>
</rfc>
